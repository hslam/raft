// Code generated by protoc-gen-hslam. DO NOT EDIT.
// source: raft.proto

// Copyright (c) 2019 Meng Huang (mhboy@outlook.com)
// This package is licensed under a MIT license that can be found in the LICENSE file.

package raft

import (
	"fmt"
	"github.com/hslam/code"
)

// Entry represents a log entry.
type Entry struct {
	Index       uint64
	Term        uint64
	CommandType uint64
	Command     []byte
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *Entry) Size() int {
	var size uint64
	size += 11
	size += 11
	size += 11
	size += 11 + uint64(len(d.Command))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *Entry) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *Entry) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Index != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Index)
		offset += n
	}
	if d.Term != 0 {
		buf[offset] = 2<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if d.CommandType != 0 {
		buf[offset] = 3<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], uint64(d.CommandType))
		offset += n
	}
	if len(d.Command) > 0 {
		buf[offset] = 4<<3 | 2
		offset++
		n = code.EncodeBytes(buf[offset:], d.Command)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *Entry) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Index)
			offset += n
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommandType", wireType)
			}
			var CommandType uint64
			n = code.DecodeVarint(data[offset:], &CommandType)
			d.CommandType = uint64(CommandType)
			offset += n
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			n = code.DecodeBytes(data[offset:], &d.Command)
			offset += n
		}
	}
	return nil
}

// RequestVoteRequest represents a rpc request of requesting vote.
type RequestVoteRequest struct {
	Term         uint64
	CandidateID  string
	LastLogIndex uint64
	LastLogTerm  uint64
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *RequestVoteRequest) Size() int {
	var size uint64
	size += 11
	size += 11 + uint64(len(d.CandidateID))
	size += 11
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *RequestVoteRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *RequestVoteRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if len(d.CandidateID) > 0 {
		buf[offset] = 2<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.CandidateID)
		offset += n
	}
	if d.LastLogIndex != 0 {
		buf[offset] = 3<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.LastLogIndex)
		offset += n
	}
	if d.LastLogTerm != 0 {
		buf[offset] = 4<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.LastLogTerm)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *RequestVoteRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandidateID", wireType)
			}
			n = code.DecodeString(data[offset:], &d.CandidateID)
			offset += n
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.LastLogIndex)
			offset += n
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.LastLogTerm)
			offset += n
		}
	}
	return nil
}

// RequestVoteResponse represents a rpc response of requesting vote.
type RequestVoteResponse struct {
	Term        uint64
	VoteGranted bool
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *RequestVoteResponse) Size() int {
	var size uint64
	size += 11
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *RequestVoteResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *RequestVoteResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if d.VoteGranted {
		buf[offset] = 2<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.VoteGranted)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *RequestVoteResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteGranted", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.VoteGranted)
			offset += n
		}
	}
	return nil
}

// AppendEntriesRequest represents a rpc request of appending entries.
type AppendEntriesRequest struct {
	Term         uint64
	LeaderID     string
	PrevLogIndex uint64
	PrevLogTerm  uint64
	LeaderCommit uint64
	Entries      []*Entry
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *AppendEntriesRequest) Size() int {
	var size uint64
	size += 11
	size += 11 + uint64(len(d.LeaderID))
	size += 11
	size += 11
	size += 11
	for i := range d.Entries {
		if d.Entries[i] != nil {
			size += 11 + uint64((d.Entries[i]).Size())
		}
	}
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *AppendEntriesRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *AppendEntriesRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if len(d.LeaderID) > 0 {
		buf[offset] = 2<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.LeaderID)
		offset += n
	}
	if d.PrevLogIndex != 0 {
		buf[offset] = 3<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.PrevLogIndex)
		offset += n
	}
	if d.PrevLogTerm != 0 {
		buf[offset] = 4<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.PrevLogTerm)
		offset += n
	}
	if d.LeaderCommit != 0 {
		buf[offset] = 5<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.LeaderCommit)
		offset += n
	}
	if len(d.Entries) > 0 {
		tag := byte(6<<3 | 2)
		for _, v := range d.Entries {
			buf[offset] = tag
			offset++
			s, err := v.MarshalTo(buf[offset+10:])
			if err != nil {
				return 0, err
			}
			size := uint64(s)
			n = code.EncodeVarint(buf[offset:], size)
			copy(buf[offset+n:], buf[offset+10:offset+10+size])
			offset += n + size
		}
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *AppendEntriesRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			n = code.DecodeString(data[offset:], &d.LeaderID)
			offset += n
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogIndex", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.PrevLogIndex)
			offset += n
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogTerm", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.PrevLogTerm)
			offset += n
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderCommit", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.LeaderCommit)
			offset += n
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			for {
				var b []byte
				n = code.DecodeBytes(data[offset:], &b)
				var entry = &Entry{}
				entry.Unmarshal(b)
				d.Entries = append(d.Entries, entry)
				offset += n
				if offset < length {
					tmpTag := uint64(data[offset])
					if tmpTag == tag {
						offset++
						continue
					}
				}
				break
			}
		}
	}
	return nil
}

// AppendEntriesResponse represents a rpc response of appending entries.
type AppendEntriesResponse struct {
	Term      uint64
	Success   bool
	NextIndex uint64
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *AppendEntriesResponse) Size() int {
	var size uint64
	size += 11
	size += 11
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *AppendEntriesResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *AppendEntriesResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if d.Success {
		buf[offset] = 2<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.Success)
		offset += n
	}
	if d.NextIndex != 0 {
		buf[offset] = 3<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.NextIndex)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *AppendEntriesResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.Success)
			offset += n
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextIndex", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.NextIndex)
			offset += n
		}
	}
	return nil
}

// InstallSnapshotRequest represents a rpc request of installing snapshot.
type InstallSnapshotRequest struct {
	Term              uint64
	LeaderID          string
	LastIncludedIndex uint64
	LastIncludedTerm  uint64
	Offset            uint64
	Done              bool
	Data              []byte
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *InstallSnapshotRequest) Size() int {
	var size uint64
	size += 11
	size += 11 + uint64(len(d.LeaderID))
	size += 11
	size += 11
	size += 11
	size += 11
	size += 11 + uint64(len(d.Data))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *InstallSnapshotRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *InstallSnapshotRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if len(d.LeaderID) > 0 {
		buf[offset] = 2<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.LeaderID)
		offset += n
	}
	if d.LastIncludedIndex != 0 {
		buf[offset] = 3<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.LastIncludedIndex)
		offset += n
	}
	if d.LastIncludedTerm != 0 {
		buf[offset] = 4<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.LastIncludedTerm)
		offset += n
	}
	if d.Offset != 0 {
		buf[offset] = 5<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Offset)
		offset += n
	}
	if d.Done {
		buf[offset] = 6<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.Done)
		offset += n
	}
	if len(d.Data) > 0 {
		buf[offset] = 7<<3 | 2
		offset++
		n = code.EncodeBytes(buf[offset:], d.Data)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *InstallSnapshotRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			n = code.DecodeString(data[offset:], &d.LeaderID)
			offset += n
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIncludedIndex", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.LastIncludedIndex)
			offset += n
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIncludedTerm", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.LastIncludedTerm)
			offset += n
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Offset)
			offset += n
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.Done)
			offset += n
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			n = code.DecodeBytes(data[offset:], &d.Data)
			offset += n
		}
	}
	return nil
}

// InstallSnapshotResponse represents a rpc response of installing snapshot.
type InstallSnapshotResponse struct {
	Term      uint64
	Offset    uint64
	NextIndex uint64
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *InstallSnapshotResponse) Size() int {
	var size uint64
	size += 11
	size += 11
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *InstallSnapshotResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *InstallSnapshotResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if d.Offset != 0 {
		buf[offset] = 2<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Offset)
		offset += n
	}
	if d.NextIndex != 0 {
		buf[offset] = 3<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.NextIndex)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *InstallSnapshotResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Offset)
			offset += n
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextIndex", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.NextIndex)
			offset += n
		}
	}
	return nil
}

// Member represents a node info.
type Member struct {
	Address   string
	NonVoting bool
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *Member) Size() int {
	var size uint64
	size += 11 + uint64(len(d.Address))
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *Member) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *Member) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if len(d.Address) > 0 {
		buf[offset] = 1<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.Address)
		offset += n
	}
	if d.NonVoting {
		buf[offset] = 2<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.NonVoting)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *Member) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			n = code.DecodeString(data[offset:], &d.Address)
			offset += n
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NonVoting", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.NonVoting)
			offset += n
		}
	}
	return nil
}

// ConfigurationStorage represents a configuration storage.
type ConfigurationStorage struct {
	Members []*Member
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *ConfigurationStorage) Size() int {
	var size uint64
	for i := range d.Members {
		if d.Members[i] != nil {
			size += 11 + uint64((d.Members[i]).Size())
		}
	}
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *ConfigurationStorage) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *ConfigurationStorage) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if len(d.Members) > 0 {
		tag := byte(1<<3 | 2)
		for _, v := range d.Members {
			buf[offset] = tag
			offset++
			s, err := v.MarshalTo(buf[offset+10:])
			if err != nil {
				return 0, err
			}
			size := uint64(s)
			n = code.EncodeVarint(buf[offset:], size)
			copy(buf[offset+n:], buf[offset+10:offset+10+size])
			offset += n + size
		}
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *ConfigurationStorage) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			for {
				var b []byte
				n = code.DecodeBytes(data[offset:], &b)
				var member = &Member{}
				member.Unmarshal(b)
				d.Members = append(d.Members, member)
				offset += n
				if offset < length {
					tmpTag := uint64(data[offset])
					if tmpTag == tag {
						offset++
						continue
					}
				}
				break
			}
		}
	}
	return nil
}

// DefaultCommand represents a operation command.
type DefaultCommand struct {
	Operation uint64
	Member    *Member
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *DefaultCommand) Size() int {
	var size uint64
	size += 11
	if d.Member != nil {
		size += 11 + uint64(d.Member.Size())
	}
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *DefaultCommand) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *DefaultCommand) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Operation != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Operation)
		offset += n
	}
	if d.Member != nil {
		buf[offset] = byte(2<<3 | 2)
		offset++
		s, err := d.Member.MarshalTo(buf[offset+10:])
		if err != nil {
			return 0, err
		} else if s == 0 {
			return 0, nil
		}
		size := uint64(s)
		n = code.EncodeVarint(buf[offset:], size)
		copy(buf[offset+n:], buf[offset+10:offset+10+size])
		offset += n + size
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *DefaultCommand) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Operation)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var b []byte
			n = code.DecodeBytes(data[offset:], &b)
			if d.Member == nil {
				d.Member = &Member{}
			}
			d.Member.Unmarshal(b)
			offset += n
		}
	}
	return nil
}

// GetLeaderRequest represents a rpc request of getting leader.
type GetLeaderRequest struct {
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *GetLeaderRequest) Size() int {
	return 0
}

// Marshal returns the encoded bytes.
func (d *GetLeaderRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *GetLeaderRequest) MarshalTo(buf []byte) (int, error) {
	return 0, nil
}

// Unmarshal unmarshals from data.
func (d *GetLeaderRequest) Unmarshal(data []byte) error {
	return nil
}

// GetLeaderResponse represents a rpc response of getting leader.
type GetLeaderResponse struct {
	Term     uint64
	LeaderID string
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *GetLeaderResponse) Size() int {
	var size uint64
	size += 11
	size += 11 + uint64(len(d.LeaderID))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *GetLeaderResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *GetLeaderResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Term != 0 {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeVarint(buf[offset:], d.Term)
		offset += n
	}
	if len(d.LeaderID) > 0 {
		buf[offset] = 2<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.LeaderID)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *GetLeaderResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			n = code.DecodeVarint(data[offset:], &d.Term)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			n = code.DecodeString(data[offset:], &d.LeaderID)
			offset += n
		}
	}
	return nil
}

// AddMemberRequest represents a rpc request of adding peer.
type AddMemberRequest struct {
	Member *Member
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *AddMemberRequest) Size() int {
	var size uint64
	size += 11 + uint64(d.Member.Size())
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *AddMemberRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *AddMemberRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Member != nil {
		buf[offset] = byte(1<<3 | 2)
		offset++
		s, err := d.Member.MarshalTo(buf[offset+10:])
		if err != nil {
			return 0, err
		} else if s == 0 {
			return 0, nil
		}
		size := uint64(s)
		n = code.EncodeVarint(buf[offset:], size)
		copy(buf[offset+n:], buf[offset+10:offset+10+size])
		offset += n + size
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *AddMemberRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var b []byte
			n = code.DecodeBytes(data[offset:], &b)
			if d.Member == nil {
				d.Member = &Member{}
			}
			d.Member.Unmarshal(b)
			offset += n
		}
	}
	return nil
}

// AddMemberResponse represents a rpc response of adding peer.
type AddMemberResponse struct {
	Success  bool
	LeaderID string
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *AddMemberResponse) Size() int {
	var size uint64
	size += 11
	size += 11 + uint64(len(d.LeaderID))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *AddMemberResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *AddMemberResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Success {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.Success)
		offset += n
	}
	if len(d.LeaderID) > 0 {
		buf[offset] = 2<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.LeaderID)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *AddMemberResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.Success)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			n = code.DecodeString(data[offset:], &d.LeaderID)
			offset += n
		}
	}
	return nil
}

// RemoveMemberRequest represents a rpc request of removing peer.
type RemoveMemberRequest struct {
	Address string
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *RemoveMemberRequest) Size() int {
	var size uint64
	size += 11 + uint64(len(d.Address))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *RemoveMemberRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *RemoveMemberRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if len(d.Address) > 0 {
		buf[offset] = 1<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.Address)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *RemoveMemberRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			n = code.DecodeString(data[offset:], &d.Address)
			offset += n
		}
	}
	return nil
}

// RemoveMemberResponse represents a rpc response of removing peer.
type RemoveMemberResponse struct {
	Success  bool
	LeaderID string
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *RemoveMemberResponse) Size() int {
	var size uint64
	size += 11
	size += 11 + uint64(len(d.LeaderID))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *RemoveMemberResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *RemoveMemberResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Success {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.Success)
		offset += n
	}
	if len(d.LeaderID) > 0 {
		buf[offset] = 2<<3 | 2
		offset++
		n = code.EncodeString(buf[offset:], d.LeaderID)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *RemoveMemberResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.Success)
			offset += n
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			n = code.DecodeString(data[offset:], &d.LeaderID)
			offset += n
		}
	}
	return nil
}

// SetMetaRequest represents a rpc request of setting meta.
type SetMetaRequest struct {
	Meta []byte
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *SetMetaRequest) Size() int {
	var size uint64
	size += 11 + uint64(len(d.Meta))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *SetMetaRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *SetMetaRequest) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if len(d.Meta) > 0 {
		buf[offset] = 1<<3 | 2
		offset++
		n = code.EncodeBytes(buf[offset:], d.Meta)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *SetMetaRequest) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			n = code.DecodeBytes(data[offset:], &d.Meta)
			offset += n
		}
	}
	return nil
}

// SetMetaResponse represents a rpc response of setting meta.
type SetMetaResponse struct {
	Success bool
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *SetMetaResponse) Size() int {
	var size uint64
	size += 11
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *SetMetaResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *SetMetaResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if d.Success {
		buf[offset] = 1<<3 | 0
		offset++
		n = code.EncodeBool(buf[offset:], d.Success)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *SetMetaResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			n = code.DecodeBool(data[offset:], &d.Success)
			offset += n
		}
	}
	return nil
}

// GetMetaRequest represents a rpc request of getting meta.
type GetMetaRequest struct {
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *GetMetaRequest) Size() int {
	return 0
}

// Marshal returns the encoded bytes.
func (d *GetMetaRequest) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *GetMetaRequest) MarshalTo(buf []byte) (int, error) {
	return 0, nil
}

// Unmarshal unmarshals from data.
func (d *GetMetaRequest) Unmarshal(data []byte) error {
	return nil
}

// GetMetaResponse represents a rpc response of getting meta.
type GetMetaResponse struct {
	Meta []byte
}

// Size returns the size of the buffer required to represent the data when encoded.
func (d *GetMetaResponse) Size() int {
	var size uint64
	size += 11 + uint64(len(d.Meta))
	return int(size)
}

// Marshal returns the encoded bytes.
func (d *GetMetaResponse) Marshal() ([]byte, error) {
	size := d.Size()
	buf := make([]byte, size)
	n, err := d.MarshalTo(buf[:size])
	return buf[:n], err
}

// MarshalTo marshals into buf and returns the number of bytes.
func (d *GetMetaResponse) MarshalTo(buf []byte) (int, error) {
	var size = uint64(d.Size())
	if uint64(cap(buf)) >= size {
		buf = buf[:size]
	} else {
		return 0, fmt.Errorf("proto: buf is too short")
	}
	var offset uint64
	var n uint64
	if len(d.Meta) > 0 {
		buf[offset] = 1<<3 | 2
		offset++
		n = code.EncodeBytes(buf[offset:], d.Meta)
		offset += n
	}
	return int(offset), nil
}

// Unmarshal unmarshals from data.
func (d *GetMetaResponse) Unmarshal(data []byte) error {
	var length = uint64(len(data))
	var offset uint64
	var n uint64
	var tag uint64
	var fieldNumber int
	var wireType uint8
	for {
		if offset < length {
			tag = uint64(data[offset])
			offset++
		} else {
			break
		}
		fieldNumber = int(tag >> 3)
		wireType = uint8(tag & 0x7)
		switch fieldNumber {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			n = code.DecodeBytes(data[offset:], &d.Meta)
			offset += n
		}
	}
	return nil
}
